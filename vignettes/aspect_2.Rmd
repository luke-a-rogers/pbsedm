---
title: "Aspect 2 demonstration"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{inclusion_issue_4}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "",
  fig.width = 5,
  fig.height = 5
)
options(rmarkdown.html_vignette.check_title = FALSE)
```

```{r setup}
library(pbsEDM)
```

## Introduction

In the manuscript, the library contains the points that can be used to work out
the nearest neighbours of the focal point from which we are making a
prediction. Aspect 2 in the manuscripts concerns which points can be considered
as being in the library, and which should be excluded. Here we find that
occasionally `rEDM` inadvertently includes some points that should be excluded.

<!-- Simplifying down from inclusion_issue_5.Rmd, which was more for working -->
<!-- things out. Now have text written up can keep the vignette simpler -->

We use the simulated population time series from the manuscript, with
first-differenced values denoted $Y_t$ at $t = 1, 2, 3, ..., 99, 100$. We
extract them from the saved tibble `NY_lags_example_3`:

```{r, t_and_Y}
input <-  dplyr::select(NY_lags_example_3, t, Y_t) %>%
  dplyr::rename(Time = t)
input
```

Note that `NY_lags_example_3` already contains results. At the end of this
vignette we verifty that results using `rEDM` or `pbsEDM` have not changed (for
example due to package updates) from those saved in `NY_lags_example_3`.

We will do the simplex calculations for embedding dimension $E = 2$ using three
independent sources of code.

TODO: maybe redo pbsEDM calcs using N as input (though could be confusing), then
have more logical output. But see
inclusion issue 5 vignette and issue 29 (deleting from here for now).


## Calculations with rEDM

First, use the `rEDM` package:

```{r rEDM}
# library(rEDM)
packageVersion("rEDM")
# '1.13.0', published 2022-06-17

rEDM_res <- rEDM::Simplex(dataFrame = input,
                          columns = "Y_t",
                          target = "Y_t",
                          lib = "1 99",
                          pred = "1 99",
                          E = 2,
                          verbose = TRUE)
                          # lib and pred overlap, so leave-one-out
                          #  cross-validation is used.

rEDM_res <- rbind(c(1, input$Y_t[1], NA, NA),
                  rEDM_res)             # Add Time = 1 values, to give t = 1:100

rEDM_pred <- rEDM_res$Predictions       # Just the predicted values
```

## Calculations using pbsEDM

See the [`analyse_simple_time_series`](analyse_simple_time_series.html) vignette
for general details on using the code. Here do the simplex calculation as just
done using `rEDM`:
```{r pbsEDM}
pbsEDM_res_full <- pbsEDM(input,
                          lags = list(Y_t = c(0:1)))   # Gives full calculations

pbsEDM_pred <- pbsEDM_res_full$X_forecast[-length(pbsEDM_res_full$X_forecast)]
                                           # Just the predictions, excluding
                                           #  t=101, so also for t = 1:100
```

## Compare `pbsEDM` results with those from `rEDM`

Now to plot the `pbsEDM` predictions again those from `rEDM`:
```{r pbsredm}
plot(rEDM_pred,
     pbs_pred,
     xlab = "rEDM predictions",
     ylab = "pbsEDM predictions")
abline(a=0,
       b=1,
       col="grey")

# Work out the ones more than epsilon away
epsilon = 0.0001      # Small value for how different the predictions can be

different <- dplyr::tibble(t = input$Time,
                           rEDM_pred,
                           pbsEDM_pred) %>%
  dplyr::filter(abs(rEDM_pred - pbsEDM_pred) > epsilon)

points(different$rEDM_pred,
       different$pbsEDM_pred,
       col = "red",
       pch = 20)
```

The time indices correspond to the predicted times, so represent $t^*+1$
values, where $t^*$ is the focal time from which we make predictions:
```{r different}
different
```

So there are two time indices for which results differ between `pbsEDM` and
`rEDM`, corresponding to $t^* =$ `r different$t[1] - 1` and `r different$t[2] - 1`.

## Explaining the issue -- Aspect 2

As defined in the manuscript, vector $\bf{\tilde{x}}_t$ has components defined by
the lagged values of scalars $Y_t$. For $E=2$ we have
$$\bf{\tilde{x}}_t = [Y_t, ~Y_{t-1}].$$
For focal time $t^*$, we know $Y_{t^*}$ and are trying to predict
$Y_{t^*+1}$.

Aspect 2 in the manuscript is explicitly defined by exclusion condition (d),
namely that the library of allowable nearest neighbours cannot include
any $\bf{x}_t$ that includes $Y_{t^*+1}$, since we are trying to predict
$Y_{t^*+1}$.

Thus, the library cannot include
$$\bf{x}_{t^*+1} = [Y_{t^*+1}, ~Y_{t^*}]$$
or
$$\bf{x}_{t^*+2} = [Y_{t^*+2}, ~Y_{t^*+1}]$$
since these both contain $Y_{t^*+1}$.

### Calculations for $t^*=94$

For $t^*=94$, we have the aforementioned discrepancy between calculations:
```{r tstar94}
t_star = 94
rEDM_pred[t_star + 1]
pbsEDM_pred[t_star + 1]
```

For `pbsEDM`, the nearest neighbours are saved as output, and for $t^*=94$ have
indices and weights:
```{r neigh}
pbsEDM_res_full$neighbour_index[t_star,]
pbsEDM_res_full$neighbour_weight[t_star,]
```
giving the above prediction for $Y_{95}$ of
```{r pred95}
pbsEDM_pred[t_star+1]
```

For `rEDM` the full details of nearest neighbours does not appear to be an
available output. However, here we show that $\bf{x}_{96}$ was used as a nearest
neighbour of $\bf{x}_{94}$. We simply change the value of
$Y_{95}$ so that `rEDM::Simplex()` will not pick
$\bf{x}_{96}$ as a nearest neighbour for $\bf{x}_{94}$, and see if get the same result as
for `pbsEDM`.

```{r changedata}
input[t_star+1, ]
input_change <- input
input_change[t_star+1, "Y_t"] = 7    # Move it far out of the way so it will not be a
                                     #  nearest neighbour

# Do Simplex calculation with same options as earlier
rEDM_change_res <- rEDM::Simplex(dataFrame = input_change,
                                 columns = "Y_t",
                                 target = "Y_t",
                                 lib = "1 99",
                                 pred = "1 99",
                                 E = 2,
                                 verbose = TRUE)
rEDM_change_res <- rbind(c(1, input_change$Y_t[1], NA, NA),
                         rEDM_change_res)          # Add Time = 1 values, to give t = 1:100
rEDM_change_pred <- rEDM_change_res$Predictions    # Just the predicted values
rEDM_change_pred[t_star+1]
```

That is the same value as obtained earlier using `pbsEDM`. Thus by moving
$Y_{95}$ far away so that it definitely will not now be considered as a component of
the nearest neighbour of $\bf{x}_{94}$, we have shown that $Y_{95}$ was
originally being considered by `rEDM` as a nearest neighbour. But as explained
in condition (d), this should not be the case.

### Calculations for $t^*=75$

We now repeat the above calculations for $t^*=75$. Skipping some of the
explanatory steps, we have:
```{r tstar75}
t_star = 75
rEDM_pred[t_star + 1]
pbsEDM_pred[t_star + 1]
```
as noted above (below the figure).

Using `pbsEDM` and $t^*=75$, the indices and weights of the nearest neighbours are:
```{r neigh75}
pbsEDM_res_full$neighbour_index[t_star,]
pbsEDM_res_full$neighbour_weight[t_star,]
```

Change the value of $Y_{76}$ so that `rEDM::Simplex()` will not pick
$\bf{x}_{77}$ as a nearest neighbour for $\bf{x}_{75}$, to verify if we get the same result as
for `pbsEDM`.

```{r changedata75}
input[t_star+1, ]
input_change <- input
input_change[t_star+1, "Y_t"] = 7    # Move it far out of the way so it will not be a
                                     #  nearest neighbour

# Do Simplex calculation with same options as earlier
rEDM_change_res <- rEDM::Simplex(dataFrame = input_change,
                                 columns = "Y_t",
                                 target = "Y_t",
                                 lib = "1 99",
                                 pred = "1 99",
                                 E = 2,
                                 verbose = TRUE)
rEDM_change_res <- rbind(c(1, input_change$Y_t[1], NA, NA),
                         rEDM_change_res)          # Add Time = 1 values, to give t = 1:100
rEDM_change_pred <- rEDM_change_res$Predictions    # Just the predicted values
rEDM_change_pred[t_star+1]
```
Again, we get the same result as obtained earlier using `pbsEDM`.

Thus, we have demonstrated two examples for which `rEDM` has used $Y_{t^* + 1}$
as a nearest neighbours, which is described as Aspect 2 in the manuscript.

HERE


## Mention this briefly at the end

Mention Andy's code is available on request, but is not functionalised or generalisable for higher
$E$, and is superceded by `pbsEDM`. Note that writing of `pbsEDM` was led by
Luke Rogers, and the code is independent of the original code.

The issue is that `rEDM` seems to use $\bf{x}_{t^*+2}$ as a
nearest neighbour, but this should not be permissible.

For example, for $t^*=94$, Andy's R code calculates nearest neighbours with indices $\psi$
(saved as `psivec94`) and corresponding weights `weights94`:
```{r psi}
psivec94 = c(6, 57, 88)
weights94 = c(0.3678794, 0.3205861, 0.2895013)
```
giving the estimate of $Y_{95}$, from [S1] of Deyle et al. (2013), as
```{r Yninetyfive}
Y95est = sum(weights94 * simple_ts[psivec94+1]) / sum(weights94)
Y95est
```

The `pbsEDM` code gives the same results:
```{r}
pbs_calc$neighbour_index[94, ]
pbs_calc$neighbour_weight[94, ]
pbs_calc$X_forecast[95]
```
The following will give errors if those results don't agree:
```{r test}
testthat::expect_equal(psivec94, pbs_calc$neighbour_index[94, ])
testthat::expect_equal(weights94, pbs_calc$neighbour_weight[94, ], tolerance = 0.000001)
testthat::expect_equal(Y95est, pbs_calc$X_forecast[95])
```
However, `rEDM` gives

```{r rEDMninetyfive}
Y95est_rEDM = NY_lags_example_3$rEDM.pred[95]
Y95est_rEDM
```
as already noted above. Unlike (I think) earlier versions of `rEDM::simplex()`, the full
results (nearest neighbours etc.) do not seem returnable from `rEDM::Simplex()`
or `rEDM::simplex()` [have tried changing options `verbose, stats_only, silent`,
but none give the full results].

## Manually reproduce `rEDM` result -- TODO just do this with pbsEDM code, or results

We can reproduce the `rEDM` result by adapting Andy's manual code to allow
$\bf{x}_{96}$ to be a nearest neighbour of $\bf{x}_{94}$,  giving
```{r psi94allow}
psivec94_allow = c(96, 6, 57)   # so 6 and 57 are now 2nd and 3rd nearest neighbours
weights94_allow = c(3.678794e-01, 1.405278e-04, 4.146457e-05)
# Note that the first weight is the same as above (by definition it's always
#  exp(-1)), but the second and third are very small because x[96] is
#  very close to x[94].
Y95est_allow = sum(weights94_allow * simple_ts[psivec94_allow+1]) /
                   sum(weights94_allow)
testthat::expect_equal(Y95est_allow,
                       Y95est_rEDM)
Y95est_allow

```
which agrees with the `Y95est_rEDM` value shown above

However, the problem is that we should not be allowed to use $\bf{x}_{96}$. For
our focal time $t^* = 94$ we are trying to predict $Y_{t^*+1} = Y_{95}$. But, by
definition, $Y_{95}$ is included in $\bf{x}_{96}$ since
$$\bf{x}_{96} = [Y_{96}, Y_{95}].$$

So $\bf{x}_{96}$ should not be used to forecast $\bf{x}_{95}$, because it
explicitly contains one of the two components of $\bf{x}_{95}$ (namely the
$Y_{95}$ value that we are trying to predict). See our manuscript for full details.

The same issue occurs for $t^*=75$.

So the implementation of `rEDM` is not taking into account the fact that
$\bf{x}_t$ is a vector of lagged values.



TODO: Also mention that rho is actually better for pbsEDM than rEDM in this
example. So not that rEDM is necessarily overstating accuracy.

## Try alternative `exclusionRadius` settings for `rEDM`

Try changing `exclusionRadius` input in `rEDM::Simplex`, which "excludes vectors
from the search space of nearest neighbors if their relative time
index is within  exclusionRadius." as suggested in `rEDM` Issue 24.

Commenting out `expect_equal()` in these, because it creates error -- writing the
results manually as comments.

First try setting `exclusionRadius = 1` (`check_rEDM_excl_1` result is saved in
`pbsEDM` using `data-raw/exclusion_radius_test.R` and not run here):
```{r exclusion1, eval=FALSE}
check_rEDM_excl_1 <- rEDM::Simplex(dataFrame = input_obs,
                                   columns = "Y_t",
                                   target = "Y_t",
                                   lib = "1 99",
                                   pred = "1 99",
                                   E = 2,
                                   verbose = TRUE,
                                   exclusionRadius = 1)$Predictions
check_rEDM_excl_1 <- c(NA,
                       check_rEDM_excl_1)   # Needs extra NA to get indexing correct

testthat::expect_equal(NY_lags_example_3$rEDM.pred,
                       check_rEDM_excl_1)
# Fails:
# 2/100 mismatches (average diff: 0.969)
# [76]  1.368 - 0.838 ==  0.53
# [77] -0.381 - 1.027 == -1.41
# So two differences using Simplex() with exclusionRadius=0 (default) and 1.

testthat::expect_equal(pbs_pred,
                       check_rEDM_excl_1)
# Fails:
# 6/100 mismatches (average diff: 0.274)
# [19]  1.0614 - 1.0614 ==  5.82e-06 #small
# [23]  1.4783 - 1.4783 ==  8.08e-06 #small
# [77] -0.3812 - 1.0266 == -1.41e+00
# [90]  2.1994 - 2.1994 ==  1.43e-05 #small
# [95]  0.4123 - 0.1774 ==  2.35e-01
# [98]  0.0799 - 0.0799 ==  3.28e-06 #small
# So [76] now matches pbs_pred, [77] for some reason has changed, [90] is
# probably close enough, but [95] still not the same as pbs_pred.
```

Then try setting it to 2, again not run here but saved in `pbsEDM`:
```{r exclusion2, eval=FALSE}
check_rEDM_excl_2 <- rEDM::Simplex(dataFrame = input_obs,
                                   columns = "Y_t",
                                   target = "Y_t",
                                   lib = "1 99",
                                   pred = "1 99",
                                   E = 2,
                                   verbose = TRUE,
                                   exclusionRadius = 2)$Predictions
check_rEDM_excl_2 <- c(NA,
                       check_rEDM_excl_2)   # Needs extra NA to get indexing correct

# testthat::expect_equal(NY_lags_example_3$rEDM.pred,
#                        check_rEDM_excl_2)
# 4/100 mismatches (average diff: 0.931)
# [76]  1.368 - 0.838 ==  0.530  # same as exclR=1
# [77] -0.381 - 1.027 == -1.408  # same as exclR=1
# [95]  0.177 - 0.412 == -0.235
# [97] -0.798 - 0.755 == -1.552
# So this has two new differences from exclR=0

# testthat::expect_equal(pbs_pred,
#                       check_rEDM_excl_2)
# [19]  1.0614 - 1.0614 ==  5.82e-06 # small
# [23]  1.4783 - 1.4783 ==  8.08e-06 # small
# [77] -0.3812 - 1.0266 == -1.41e+00
# [90]  2.1994 - 2.1994 ==  1.43e-05 # small
# [97] -0.7977 - 0.7547 == -1.55e+00
# [98]  0.0799 - 0.0799 ==  3.28e-06 # small
```
So with exclusion radius of 2, assuming the e-06 and e-05 values are equal, instead of
$t^*+1 = 76, 90$ and 95 results disagreeing between `pbsEDM` and `rEDM` results, we now
have those three agreeing, but 77 and 97 being quite different:
```{r newdiff}
# [77] -0.3812 - 1.0266 == -1.41e+00
# [97] -0.7977 - 0.7547 == -1.55e+00
```

Try exclusion radius of 3 (also saved in `pbsEDM`):
```{r exclusion3, eval=FALSE}
check_rEDM_excl_3 <- rEDM::Simplex(dataFrame = input_obs,
                                   columns = "Y_t",
                                   target = "Y_t",
                                   lib = "1 99",
                                   pred = "1 99",
                                   E = 2,
                                   verbose = TRUE,
                                   exclusionRadius = 3)$Predictions
check_rEDM_excl_3 <- c(NA,
                       check_rEDM_excl_3)   # Needs extra NA to get indexing correct

# testthat::expect_equal(NY_lags_example_3$rEDM.pred,
#                       check_rEDM_excl_3)
# 7/100 mismatches (average diff: 0.64)
# [61]  0.797 - 0.891 == -0.0943
# [64]  0.171 - 0.150 ==  0.0209
# [65]  2.883 - 3.521 == -0.6378
# [76]  1.368 - 0.838 ==  0.5299
# [77] -0.381 - 1.027 == -1.4078
# [95]  0.177 - 0.412 == -0.2350
# [97] -0.798 - 0.755 == -1.5523
# So first three values are different (but weren't for exclR = 2), last four
# have the same differences as for exclR = 2
# (expect to get more differences with larger radius).

# testthat::expect_equal(pbs_pred,
#                       check_rEDM_excl_3)
# 9/100 mismatches (average diff: 0.413)
# [19]  1.0614 - 1.0614 ==  5.82e-06
# [23]  1.4783 - 1.4783 ==  8.08e-06
# [61]  0.7967 - 0.8910 == -9.43e-02 # new
# [64]  0.1709 - 0.1500 ==  2.09e-02 # new
# [65]  2.8828 - 3.5206 == -6.38e-01 # new
# [77] -0.3812 - 1.0266 == -1.41e+00
# [90]  2.1994 - 2.1994 ==  1.43e-05
# [97] -0.7977 - 0.7547 == -1.55e+00
# [98]  0.0799 - 0.0799 ==  3.28e-06
```
The three highlighted ones are new differences for `exclusionRadius=3`,
which, as expected, does not fix the problem.

So, conclusion is that setting `exclusionRadius` in `rEDM` does not fix the problem.








## Test that rEDM and pbsEDM results have not changed

Run some tests to check that calculations are the same as those previously
saved. These give errors if they fail.

```{r tests}
# rEDM results are already saved in NY_lags_example_3; this code checks that the
#  calculations give matching results
testthat::expect_equal(NY_lags_example_3$rEDM.pred,
                       rEDM_res$Predictions)       # If no error then they match
testthat::expect_equal(NY_lags_example_3$rEDM.var,
                       rEDM_res$Pred_Variance)     # If no error then they match

# pbsEDM results with original independent code
testthat::expect_equal(NY_lags_example_3$my.pred,
                       pbsEDM_pred)
```
**Conclusion**: Andy's original manual calculations and Luke's new function in
`pbsEDM` give the same results for this simulated data set. Andy's and Luke's
code was written independently (although Andy had explained why his results
differed to those from `rEDM`). This is a reassuring test of Luke's new code,
which is more general and functionalised than Andy's, and can do more than just $E=2$.
Thus, we will continue using the `pbsEDM` results.

---
title: "Aspect 2 demonstration"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{inclusion_issue_4}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "",
  fig.width = 5,
  fig.height = 5
)
options(rmarkdown.html_vignette.check_title = FALSE)
```

```{r setup}
library(pbsEDM)
```

## Introduction

In the manuscript, the library contains the points that can be used to work out
the nearest neighbours of the focal point from which we are making a
prediction. Aspect 2 in the manuscripts concerns which points can be considered
as being in the library, and which should be excluded. Here we find that
occasionally `rEDM` inadvertently includes some points that should be excluded.

<!-- Simplifying down from inclusion_issue_5.Rmd, which was more for working -->
<!-- things out. Now have text written up can keep the vignette simpler -->

We use the simulated population time series from the manuscript, with
first-differenced values denoted $Y_t$ at $t = 1, 2, 3, ..., 99, 100$. We
extract them from the saved tibble `NY_lags_example_3`:

```{r, t_and_Y}
input <-  dplyr::select(NY_lags_example_3, t, Y_t) %>%
  dplyr::rename(Time = t)
input
```

Note that `NY_lags_example_3` already contains results. At the end of this
vignette we verifty that results using `rEDM` or `pbsEDM` have not changed (for
example due to package updates) from those saved in `NY_lags_example_3`.

We will do the simplex calculations for embedding dimension $E = 2$ using three
independent sources of code.

TODO: maybe redo pbsEDM calcs using N as input (though could be confusing), then
have more logical output. But see
inclusion issue 5 vignette and issue 29 (deleting from here for now).


## Calculations with rEDM

First, use the `rEDM` package:

```{r rEDM}
# library(rEDM)
packageVersion("rEDM")
# '1.13.0', published 2022-06-17

rEDM_res <- rEDM::Simplex(dataFrame = input,
                          columns = "Y_t",
                          target = "Y_t",
                          lib = "1 99",
                          pred = "1 99",
                          E = 2,
                          verbose = TRUE)
                          # lib and pred overlap, so leave-one-out
                          #  cross-validation is used.

rEDM_res <- rbind(c(1, input$Y_t[1], NA, NA),
                  rEDM_res)             # Add Time = 1 values, to give t = 1:100

rEDM_pred <- rEDM_res$Predictions       # Just the predicted values
```

## Calculations using pbsEDM

See the [`analyse_simple_time_series`](analyse_simple_time_series.html) vignette
for general details on using the code. Here do the simplex calculation as just
done using `rEDM`:
```{r pbsEDM}
pbsEDM_res_full <- pbsEDM(input,
                          lags = list(Y_t = c(0:1)))   # Gives full calculations

pbsEDM_pred <- pbsEDM_res_full$X_forecast[-length(pbsEDM_res_full$X_forecast)]
                                           # Just the predictions, excluding
                                           #  t=101, so also for t = 1:100
```

## Compare `pbsEDM` results with those from `rEDM`

Now to plot the `pbsEDM` predictions again those from `rEDM`:
```{r pbsredm}
plot(rEDM_pred,
     pbs_pred,
     xlab = "rEDM predictions",
     ylab = "pbsEDM predictions")
abline(a=0,
       b=1,
       col="grey")

# Work out the ones more than epsilon away
epsilon = 0.0001      # Small value for how different the predictions can be

different <- dplyr::tibble(t = input$Time,
                           rEDM_pred,
                           pbsEDM_pred) %>%
  dplyr::filter(abs(rEDM_pred - pbsEDM_pred) > epsilon)

points(different$rEDM_pred,
       different$pbsEDM_pred,
       col = "red",
       pch = 20)
```

The time indices correspond to the predicted times, so represent $t^*+1$
values, where $t^*$ is the focal time from which we make predictions:
```{r different}
different
```

So there are two time indices for which results differ between `pbsEDM` and
`rEDM`, corresponding to $t^* =$ `r different$t[1] - 1` and `r different$t[2] - 1`.

## Explaining the issue -- Aspect 2

As defined in the manuscript, vector $\bf{\tilde{x}}_t$ has components defined by
the lagged values of scalars $Y_t$. For $E=2$ we have
$$\bf{\tilde{x}}_t = [Y_t, ~Y_{t-1}].$$
For focal time $t^*$, we know $Y_{t^*}$ and are trying to predict
$Y_{t^*+1}$.

Aspect 2 in the manuscript is explicitly defined by exclusion condition (d),
namely that the library of allowable nearest neighbours cannot include
any $\bf{x}_t$ that includes $Y_{t^*+1}$, since we are trying to predict
$Y_{t^*+1}$.

Thus, the library cannot include
$$\bf{x}_{t^*+1} = [Y_{t^*+1}, ~Y_{t^*}]$$
or
$$\bf{x}_{t^*+2} = [Y_{t^*+2}, ~Y_{t^*+1}]$$
since these both contain $Y_{t^*+1}$.

### Calculations for $t^*=94$

For $t^*=94$, we have the aforementioned discrepancy between calculations:
```{r tstar94}
t_star = 94
rEDM_pred[t_star + 1]
pbsEDM_pred[t_star + 1]
```

For `pbsEDM`, the nearest neighbours are saved as output, and for $t^*=94$ have
indices and weights:
```{r neigh}
pbsEDM_res_full$neighbour_index[t_star,]
pbsEDM_res_full$neighbour_weight[t_star,]
```
giving the above prediction for $Y_{95}$ of
```{r pred95}
pbsEDM_pred[t_star+1]
```

For `rEDM` the full details of nearest neighbours does not appear to be an
available output. However, here we show that $\bf{x}_{96}$ was used as a nearest
neighbour of $\bf{x}_{94}$. We simply change the value of
$Y_{95}$ so that `rEDM::Simplex()` will not pick
$\bf{x}_{96}$ as a nearest neighbour for $\bf{x}_{94}$, and see if get the same result as
for `pbsEDM`.

```{r changedata}
input[t_star+1, ]
input_change <- input
input_change[t_star+1, "Y_t"] = 7    # Move it far out of the way so it will not be a
                                     #  nearest neighbour

# Do Simplex calculation with same options as earlier
rEDM_change_res <- rEDM::Simplex(dataFrame = input_change,
                                 columns = "Y_t",
                                 target = "Y_t",
                                 lib = "1 99",
                                 pred = "1 99",
                                 E = 2,
                                 verbose = TRUE)
rEDM_change_res <- rbind(c(1, input_change$Y_t[1], NA, NA),
                         rEDM_change_res)          # Add Time = 1 values, to give t = 1:100
rEDM_change_pred <- rEDM_change_res$Predictions    # Just the predicted values
rEDM_change_pred[t_star+1]
```

That is the same value as obtained earlier using `pbsEDM`. Thus by moving
$Y_{95}$ far away so that it definitely will not now be considered as a component of
the nearest neighbour of $\bf{x}_{94}$, we have shown that $Y_{95}$ was
originally being considered by `rEDM` as a nearest neighbour. But as explained
in condition (d), this should not be the case.

### Calculations for $t^*=75$

We now repeat the above calculations for $t^*=75$. Skipping some of the
explanatory steps, we have:
```{r tstar75}
t_star = 75
rEDM_pred[t_star + 1]
pbsEDM_pred[t_star + 1]
```
as noted above (below the figure).

Using `pbsEDM` and $t^*=75$, the indices and weights of the nearest neighbours are:
```{r neigh75}
pbsEDM_res_full$neighbour_index[t_star,]
pbsEDM_res_full$neighbour_weight[t_star,]
```

Change the value of $Y_{76}$ so that `rEDM::Simplex()` will not pick
$\bf{x}_{77}$ as a nearest neighbour for $\bf{x}_{75}$, to verify if we get the same result as
for `pbsEDM`.

```{r changedata75}
input[t_star+1, ]
input_change <- input
input_change[t_star+1, "Y_t"] = 7    # Move it far out of the way so it will not be a
                                     #  nearest neighbour

# Do Simplex calculation with same options as earlier
rEDM_change_res <- rEDM::Simplex(dataFrame = input_change,
                                 columns = "Y_t",
                                 target = "Y_t",
                                 lib = "1 99",
                                 pred = "1 99",
                                 E = 2,
                                 verbose = TRUE)
rEDM_change_res <- rbind(c(1, input_change$Y_t[1], NA, NA),
                         rEDM_change_res)          # Add Time = 1 values, to give t = 1:100
rEDM_change_pred <- rEDM_change_res$Predictions    # Just the predicted values
rEDM_change_pred[t_star+1]
```
Again, we get the same result as obtained earlier using `pbsEDM`.

Thus, we have demonstrated two examples for which `rEDM` has used $Y_{t^* + 1}$
as a nearest neighbours, which is described as Aspect 2 in the manuscript.

TODO: Also mention that rho is actually better for pbsEDM than rEDM in this
example. So not that rEDM is necessarily overstating accuracy.

## Try alternative `exclusionRadius` settings for `rEDM`

We now try changing `exclusionRadius` input in `rEDM::Simplex`, which (from `?Simplex`)
"excludes vectors
from the search space of nearest neighbors if their relative time
index is within  exclusionRadius."

So, re-using the above code and trying `exclusionRadius`=1 (the
default is 0):
```{r exclusion1}
rEDM_res_excl_1 <- rEDM::Simplex(dataFrame = input,
                                 columns = "Y_t",
                                 target = "Y_t",
                                 lib = "1 99",
                                 pred = "1 99",
                                 E = 2,
                                 verbose = TRUE,
                                 exclusionRadius = 1)

rEDM_res_excl_1 <- rbind(c(1, input$Y_t[1], NA, NA),
                         rEDM_res_excl_1)             # Add Time = 1 values, to give t = 1:100

rEDM_pred_excl_1 <- rEDM_res_excl_1$Predictions       # Just the predicted values

different_excl <- dplyr::tibble(t = input$Time,
                                pbsEDM_pred,
                                rEDM_pred,
                                rEDM_pred_excl_1)

# See what has changed from original rEDM results
dplyr::filter(different_excl,
              abs(rEDM_pred - rEDM_pred_excl_1) > epsilon)
```

The $t$ values shown are for the predictions at $t = t^* + 1$. So the `rEDM`
results have changed for $t^* = 75$ (which is good) and 76 (which is not
expected), but not for the desired $t^* = 94$.

Now check what is different to `pbsEDM` results:

```{r excl1diff}
dplyr::filter(different_excl,
              abs(pbsEDM_pred - rEDM_pred_excl_1) > epsilon)
```

So $t^* = 75$, which we just found had changed with the `exclusionRadius`=1, is
not shown here meaning that it now matches the `pbsEDM` result. Thus Aspect 2
has been corrected for
that value. But $t^* = 94$ is still different to the `pbsEDM` results, so the
correction isn't global, and $t^* = 76$ is now different.

So we now try setting `exclusionRadius`=2:
```{r exclusion2}
rEDM_res_excl_2 <- rEDM::Simplex(dataFrame = input,
                                 columns = "Y_t",
                                 target = "Y_t",
                                 lib = "1 99",
                                 pred = "1 99",
                                 E = 2,
                                 verbose = TRUE,
                                 exclusionRadius = 2)

rEDM_res_excl_2 <- rbind(c(1, input$Y_t[1], NA, NA),
                         rEDM_res_excl_2)             # Add Time = 1 values, to give t = 1:100

rEDM_pred_excl_2 <- rEDM_res_excl_2$Predictions       # Just the predicted values

different_excl <- dplyr::mutate(different_excl,
                                rEDM_pred_excl_2)

# See what has changed from original rEDM results
dplyr::filter(different_excl,
              abs(rEDM_pred - rEDM_pred_excl_2) > epsilon)
```

So with `exclusionRadius`=2, the `rEDM` results have changed from the original
predictions for $t^* = 75, 76, 94$ and $96$. Checking what is now different to the
`pbsEDM` results:

```{r excl2diff}
dplyr::filter(different_excl,
              abs(pbsEDM_pred - rEDM_pred_excl_2) > epsilon)
```

So $t^* = 76$ and $96$ are different to the `pbsEDM` results. So while setting
`exclusionRadius` equal to 2
seems to have 'fixed' Aspect 2 for $t^* = 75$ and $94$, this has led to incorrect
predictions for $t^* = 76$ and $96$.

Repeating the above with `exclusionRadius`=3 leads to five differences with the `pbsEDM`
results (results not shown).

So, we conclude that change `exclusionRadius` in the call to `rEDM::Simplex()`
does not fix Aspect 2.

## Test that rEDM and pbsEDM results have not changed

TODO: Mention Andy's code is available on request, but is not functionalised or generalisable for higher
$E$, and is superceded by `pbsEDM`. Note that writing of `pbsEDM` was led by
Luke Rogers, and the code is independent of the original code.

And:

We can reproduce the `rEDM` result by adapting Andy's manual code to allow
$\bf{x}_{96}$ to be a nearest neighbour of $\bf{x}_{94}$,  giving
```{r psi94allow}
psivec94_allow = c(96, 6, 57)   # so 6 and 57 are now 2nd and 3rd nearest neighbours
weights94_allow = c(3.678794e-01, 1.405278e-04, 4.146457e-05)
# Note that the first weight is the same as above (by definition it's always
#  exp(-1)), but the second and third are very small because x[96] is
#  very close to x[94].
Y95est_allow = sum(weights94_allow * simple_ts[psivec94_allow+1]) /
                   sum(weights94_allow)
testthat::expect_equal(Y95est_allow,
                       Y95est_rEDM)
Y95est_allow

```
which agrees with the `Y95est_rEDM` value shown above

--

Run some tests to check that calculations are the same as those previously
saved. These give errors if they fail.

```{r tests}
# rEDM results are already saved in NY_lags_example_3; this code checks that the
#  calculations give matching results
testthat::expect_equal(NY_lags_example_3$rEDM.pred,
                       rEDM_res$Predictions)       # If no error then they match
testthat::expect_equal(NY_lags_example_3$rEDM.var,
                       rEDM_res$Pred_Variance)     # If no error then they match

# pbsEDM results with original independent code
testthat::expect_equal(NY_lags_example_3$my.pred,
                       pbsEDM_pred)
```
**Conclusion**: Andy's original manual calculations and Luke's new function in
`pbsEDM` give the same results for this simulated data set. Andy's and Luke's
code was written independently (although Andy had explained why his results
differed to those from `rEDM`). This is a reassuring test of Luke's new code,
which is more general and functionalised than Andy's, and can do more than just $E=2$.
Thus, we will continue using the `pbsEDM` results.

Also check that the `rEDM::Simplex()` calculations have not changed, by
comparing a saved version in `pbsEDM` to those calculated above (if these give
an error then `rEDM` has changed and the text above would need updating):
```{r testExcl}
testthat::expect_equal(check_rEDM_excl_1, rEDM_pred_excl_1)
testthat::expect_equal(check_rEDM_excl_2, rEDM_pred_excl_2)
testthat::expect_equal(check_rEDM_excl_3, rEDM_pred_excl_3)
```

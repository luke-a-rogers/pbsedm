---
title: "mve_understanding"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{mve_understanding}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7.1,
  fig.height = 6,
  fig.retina = 2
)
```

```{r setup}
load_all() # library(pbsEDM)
library(dplyr)
library(tidyr)
library(magrittr)
library(ggplot2)
```

Adapting Luke's original `mve.Rmd` to dig into his mve functions. Was going
use the same default time series as in `analyse_simple_time_series.Rmd` but
that's univariate, so stick with his larkin one.

```{r larkin}
larkin
```

```{r visualize}
plot(larkin$time,
     larkin$recruits,
     type = "o",
     ylim = c(0, 0.2))
```

This is different format to what we have in `salmon_sim()`, so switching to
ours.
<!-- Returns are the total returns in year $t$, $r_3, r_4$, and $r_5$ are the
recruits from year $t$ that will return later. These are $R'_t$ in our write up,
so change to $R_prime_t$. Actually, not quite. So switching to ours. TODO delete -->
<!-- me when no longer needed -->

```{r simulated}
simulated <- EDMsimulate::salmon_sim()
simulated
```

Here's what we have in `EDMsimulate::sim_and_fit` and `..._realisations()`, so adapt those
(not evaluating here):
```{r simandfit, eval = FALSE}
# sim_and_fit():
sim_and_fit <- function(salmon_sim_args = list(),
                        pbsEDM_args = list(
                          lags = list(R_switch = 0,
                                      S_t = 0:3)),
                        R_switch = "R_prime_t"){

  stopifnot(R_switch %in% c("R_t", "R_prime_t"))
  stopifnot(names(pbsEDM_args$lags)[1] == "R_switch")
  names(pbsEDM_args$lags)[1] <- R_switch

  simulated <- do.call(salmon_sim,
                       salmon_sim_args)

  simulated_use <- simulated
  simulated_use[nrow(simulated_use), R_switch] = NA    # Ensure no
                                        # knowledge of it for pbsEDM(), so it
                                        # doesn't affect the rho values (else it does)

  fit <- do.call(pbsEDM::pbsEDM,
                 c(list(N = simulated_use),
                   pbsEDM_args))

  to_return <- list(simulated = simulated,
                    fit = fit)
  # concatenated list, with simulated tibble first then list of all results from pbsEDM
  return(to_return) # for now, probably want to scale down or have option to
                    # just return basic results for when doing many simulations
}

# sim_and_fit_realisations(), part of:
    if(edm_fit){
      fit_edm <- do.call(pbsEDM::pbsEDM,
                         c(list(N = all_sims[[m]]),
                           pbsEDM_args))

      testthat::expect_equal(dplyr::pull(all_sims[[m]], R_switch),
                             fit_edm$N_observed[-(T+1)])  # Extra check

      fit_edm_full_series[m, ]  <- t(c(m,
                                       fit_edm$N_forecast))

      res_realisations[m, "R_switch_T_edm_fit"] = fit_edm$N_forecast[T] # TODO
                                        # double check what to do when pbsedm
                                        # arguments change
      res_realisations[m, "E"] = fit_edm$results$E  # Though will need specific
                                                    # lags also kept track of or specified
      res_realisations[m, "N_rho"] = fit_edm$results$N_rho
      res_realisations[m, "N_rmse"] = fit_edm$results$N_rmse
      res_realisations[m, "X_rho"] = fit_edm$results$X_rho
      res_realisations[m, "X_rmse"] = fit_edm$results$X_rmse
    }
```

First just try a simple call to `single_view_embedding`, and based on the top
function above, use
```{r lagstouse}
lags_use <- list(# R_prime_t = 0,  # not for single_view I think
                 S_t = 0:3)
```

Here's what Luke had for Larkin, then try that for mine
```{r forecastlarkin}
# Larkin
if(TRUE){
  f0 <- pbsEDM::single_view_embedding(
    data = larkin,
    response = "recruits",
    lags = list(spawners = 0:8),
    index = 60,
    buffer = 10,
    window = integer(0),
    metric = "rmse",
    beyond = FALSE
  )

  f0 %>% as.data.frame()
}
```

Now try that for one of our examples, then dig into code with `browser()` to
trace what is being done. Then change arguments.

```{r forecast}
index_val <- 60
buffer_val <- 10
sve_on_simulated <- single_view_embedding(data = simulated,
                                          response = "R_prime_t",
                                          lags = lags_use,
                                          index = index_val,   # not sure what this is
                                          buffer = buffer_val,  # number of forecasts
                                            # prior to index, not sure exatly
                                            # what that means
                                          window = integer(0),  # forecast
                                            # metric moving window width, aha -
                                            # our issue with before and after I
                                            # think maybe
                                          metric = "rmse",  # presumably the
                                            # metric to test something
                                          beyond = FALSE)
sve_on_simulated %>% as.data.frame()
summary(sve_on_simulated)
```

Looks like it's only using information up to that point in time, going by the
points column. Don't think we need that (i.e. use all the data) as we're going
to test performance on the $T+1$ point. Deconstruct the function to understand
methods:

```{r ss}
ssr <- state_space_reconstruction(data = simulated,
                                  response = "R_prime_t",
                                  lags = lags_use)
head(simulated)
head(ssr)
```
Returns centred and scaled values. Have gone through function.

```{r ssd}
distances <- state_space_distances(ssr,
                                   index = index_val, # time index of the first value
                                        # to forecast - but why would you do
                                        # this? Ignore a transient, or a library
                                        # thing? TODO
                                   buffer = buffer_val)  # number of values to forecast
                                        # before index. Not sure why, vaguely
                                        # remember a discussion about it. TODO

# From single_view_embedding() for this (changin X to ssr, X_distance to distances)
  # - Rows in X are points in the SSR
  # - Each row in X_distance corresponds to a focal point in the SSR
  # - Each column in X_distance corresponds to a potential neighbour in the SSR
  # - Elements of X_distance correspond to distances to neighbours
  # - NA elements indicate disallowed neighbours for a given focal point

as_tibble(distances)
summary(distances) # First three and last columns always NA's. Rest have at
                   # least 49.
tail(distances)

# Next:
  # Compute centred and scaled forecasts ---------------------------------------

  # - Create neighbour index matrix
  # - Create neighbour matrices
  # - Project neighbour matrices
  # - Compute ssr_forecast vector
ssr_forecasts <- state_space_forecasts(ssr,
                                       distances,
                                       beyond = FALSE)
ssr_forecasts


observed <- c(dplyr::pull(simulated,
                          "R_prime_t"),
              NA)[seq_along(ssr_forecasts)]  # Not sure what NA does, gets
                                        # ignored anyway.
observed   # vector of observations

forecast <- untransform_forecasts(observed,
                                  ssr_forecasts)   # scale back to
                                                   # non-normalised

rows <- seq_along(forecast)

# This is what single_view_embedding() returns, set is being defined here:
sve_on_simulated_manually <- tibble(set = rep(0:1,
                                              c(index_val - 1,
                                                nrow(simulated) - index_val + 2))[rows],
                                    time = seq_len(nrow(simulated) + 1L)[rows],
                                    points = c(0,
                                               as.vector(apply(distances,
                                                               1,
                                                               function (x) sum(!is.na(x)))))[rows],
                                    dim = rep(ncol(ssr),
                                              nrow(simulated) + 1L)[rows],
                                    observed = observed,
                                    forecast = forecast,
                                    forecast_metrics(observed, forecast, integer(0),
                                                     "rmse"),   # all NA's
                                                       # though, running rms
                                                       # error but with window
                                                       # of 0, so all NA's
                                                       # through
                                                       # runner::runner() I
                                                       # think. Not sure the
                                                       # point of it, just
                                                       # leave. BUT were not all
                                                       # NA's in
                                                       # sve_on_simulated. OKAY
                                                       # - 0 gives all NA's, but
                                                       # integer(0) does not; strange
                                    superset_columns(simulated, lags_use, NULL))

superset_columns(simulated, lags_use, NULL)   # so creates extra columns, all 1's
                                        # though, not sure of the point.

expect_equal(sve_on_simulated,
             sve_on_simulated_manually)
# Error: `sve_on_simulated` not equal to `sve_on_simulated_manually`.
# Names: 4 string mismatches
# Length mismatch: comparison on first 12 components
# Component "mre": Modes: numeric, logical
# Component "mre": target is numeric, current is logical
# Component "rmse": Modes: numeric, logical
# Component "rmse": target is numeric, current is logical


```



HERE

Use as template when get to mve:

```{r larkinmve}
# Larkin
if(FALSE){
  f01 <- pbsEDM::mve(
    data = larkin,
    response = "recruits",
    lags = list(spawners = 0:8),
    index = 60,
    buffer = 10,
    window = integer(0),
    metric = "rmse",
    beyond = FALSE,
    weight = NULL,
    n_weight = 1,
    cores = NULL)

  f01$ranks
  f01$summary
  f01$hindsight
  f01$results
  f01$forecast
}
```
